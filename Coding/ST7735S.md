
```python


#!/usr/bin/env python3
"""
Minimal ST7735S SPI driver for Raspberry Pi (Python)

- Assumes:
    * ST7735S in 4-wire SPI mode
    * 16-bit color (RGB565)
    * 128x160 panel (very common; adjust WIDTH/HEIGHT if needed)

- Wiring (BCM pins; change to your wiring):
    * SPI0 SCLK  -> TFT SCL / SCK
    * SPI0 MOSI  -> TFT SDA / MOSI
    * CE0 (SPI0) -> TFT CS  (or wire CS permanently low and ignore)
    * DC_PIN     -> TFT D/C
    * RST_PIN    -> TFT RESET / RES
    * BL_PIN     -> TFT backlight (optional, or tie to 3V3)

Enable SPI on Pi:
    sudo raspi-config   # Interface Options -> SPI -> Enable

Install dependencies:
    sudo apt-get install python3-spidev python3-rpi.gpio

Run:
    python3 st7735s_demo.py
"""

import time
from typing import Tuple

import RPi.GPIO as GPIO
import spidev


# -----------------------------
# Pin / display configuration
# -----------------------------

# BCM pin numbers (change if you wire differently)
DC_PIN = 25        # Data/Command select
RST_PIN = 24       # Reset
BL_PIN = 18        # Backlight (optional; set to None if not used)

# SPI configuration
SPI_BUS = 0
SPI_DEVICE = 0
SPI_MAX_HZ = 12_000_000  # 12 MHz is usually fine

# Panel resolution (common ST7735S TFT)
WIDTH = 128
HEIGHT = 160


# -----------------------------
# Low-level ST7735S driver
# -----------------------------

class ST7735S:
    """
    Very small ST7735S driver:
    - init()
    - fill_screen()
    - draw_pixel()
    - fill_rect()
    """

    def __init__(self) -> None:
        self.width = WIDTH
        self.height = HEIGHT

        GPIO.setmode(GPIO.BCM)
        GPIO.setwarnings(False)

        GPIO.setup(DC_PIN, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(RST_PIN, GPIO.OUT, initial=GPIO.HIGH)
        if BL_PIN is not None:
            GPIO.setup(BL_PIN, GPIO.OUT, initial=GPIO.HIGH)

        self._spi = spidev.SpiDev()
        self._spi.open(SPI_BUS, SPI_DEVICE)
        self._spi.max_speed_hz = SPI_MAX_HZ
        self._spi.mode = 0  # CPOL=0, CPHA=0

        self._init_display()

    # ---------- GPIO helpers ----------

    def _reset(self) -> None:
        """Hardware reset using RESX pin."""
        GPIO.output(RST_PIN, GPIO.HIGH)
        time.sleep(0.01)
        GPIO.output(RST_PIN, GPIO.LOW)
        time.sleep(0.01)
        GPIO.output(RST_PIN, GPIO.HIGH)
        time.sleep(0.12)  # ≥ 120ms after reset :contentReference[oaicite:0]{index=0}

    def _write_cmd(self, cmd: int) -> None:
        """Send a single byte command (D/C low)."""
        GPIO.output(DC_PIN, GPIO.LOW)
        self._spi.writebytes([cmd & 0xFF])

    def _write_data(self, data: bytes) -> None:
        """Send data bytes (D/C high)."""
        GPIO.output(DC_PIN, GPIO.HIGH)
        if data:
            # spidev wants list[int] or bytes; bytes is fine
            self._spi.writebytes(list(data))

    # ---------- Display init / commands ----------

    def _init_display(self) -> None:
        """
        Basic init using ST7735S command list:

        Key commands from datasheet:
        - SWRESET (0x01) Software Reset :contentReference[oaicite:1]{index=1}
        - SLPOUT  (0x11) Sleep Out & Booster On :contentReference[oaicite:2]{index=2}
        - COLMOD  (0x3A) Interface Pixel Format (0x05 = 16-bit RGB565) :contentReference[oaicite:3]{index=3}
        - MADCTL  (0x36) Memory Data Access Control (orientation etc.) :contentReference[oaicite:4]{index=4}
        - CASET   (0x2A) Column Address Set :contentReference[oaicite:5]{index=5}
        - RASET   (0x2B) Row Address Set :contentReference[oaicite:6]{index=6}
        - RAMWR   (0x2C) Memory Write :contentReference[oaicite:7]{index=7}
        - DISPON  (0x29) Display On :contentReference[oaicite:8]{index=8}
        """

        self._reset()

        # Software reset
        self._write_cmd(0x01)  # SWRESET
        time.sleep(0.15)

        # Sleep out
        self._write_cmd(0x11)  # SLPOUT
        time.sleep(0.12)

        # Pixel format: 16-bit (RGB565)
        self._write_cmd(0x3A)  # COLMOD
        # IFPF[2:0] = 0b101 -> 16-bit/pixel RGB565 :contentReference[oaicite:9]{index=9}
        self._write_data(bytes([0x05]))

        # Memory data access control (orientation, RGB/BGR, row/col order).
        # 0x00 is a good default (top-left origin, RGB).
        self._write_cmd(0x36)  # MADCTL
        self._write_data(bytes([0x00]))

        # Optional: frame rate, inversion, power settings can be tweaked here.
        # For many modules, factory NV/OTP defaults are good enough.

        # Display ON
        self._write_cmd(0x29)  # DISPON
        time.sleep(0.05)

        # Clear screen to black
        self.fill_screen(0x0000)

    def _set_address_window(
        self,
        x0: int,
        y0: int,
        x1: int,
        y1: int,
    ) -> None:
        """
        Set the rectangular RAM area for the next RAMWR.

        Uses CASET (0x2A) and RASET (0x2B) as per datasheet. :contentReference[oaicite:10]{index=10}
        """
        # Clamp input
        x0 = max(0, min(self.width - 1, x0))
        y0 = max(0, min(self.height - 1, y0))
        x1 = max(0, min(self.width - 1, x1))
        y1 = max(0, min(self.height - 1, y1))

        # Column address set
        self._write_cmd(0x2A)  # CASET
        data = bytes([
            (x0 >> 8) & 0xFF,
            x0 & 0xFF,
            (x1 >> 8) & 0xFF,
            x1 & 0xFF,
        ])
        self._write_data(data)

        # Row address set
        self._write_cmd(0x2B)  # RASET
        data = bytes([
            (y0 >> 8) & 0xFF,
            y0 & 0xFF,
            (y1 >> 8) & 0xFF,
            y1 & 0xFF,
        ])
        self._write_data(data)

        # Write to RAM
        self._write_cmd(0x2C)  # RAMWR

    # ---------- Drawing primitives ----------

    @staticmethod
    def rgb565(r: int, g: int, b: int) -> int:
        """
        Convert 8-bit/channel RGB (0–255) to 16-bit RGB565.
        Matches 16-bit mode described in datasheet (5-6-5). :contentReference[oaicite:11]{index=11}
        """
        r5 = (r & 0xF8) >> 3
        g6 = (g & 0xFC) >> 2
        b5 = (b & 0xF8) >> 3
        return (r5 << 11) | (g6 << 5) | b5

    @staticmethod
    def _color_to_bytes(color: int) -> bytes:
        """Convert a 16-bit RGB565 color to two bytes, big-endian."""
        return bytes([(color >> 8) & 0xFF, color & 0xFF])

    def draw_pixel(self, x: int, y: int, color: int) -> None:
        """Draw a single pixel at (x, y) with 16-bit RGB565 color."""
        if not (0 <= x < self.width and 0 <= y < self.height):
            return
        self._set_address_window(x, y, x, y)
        self._write_data(self._color_to_bytes(color))

    def fill_rect(
        self,
        x: int,
        y: int,
        w: int,
        h: int,
        color: int,
    ) -> None:
        """
        Fill a rectangle with RGB565 color.
        Coordinates can extend off-screen; they are clipped.
        """
        if w <= 0 or h <= 0:
            return

        x1 = x + w - 1
        y1 = y + h - 1

        # Clip
        if x >= self.width or y >= self.height:
            return
        if x1 < 0 or y1 < 0:
            return

        x = max(0, x)
        y = max(0, y)
        x1 = min(self.width - 1, x1)
        y1 = min(self.height - 1, y1)

        self._set_address_window(x, y, x1, y1)

        pixels = (x1 - x + 1) * (y1 - y + 1)
        color_bytes = self._color_to_bytes(color)
        # For speed, build a reasonably large chunk then repeat.
        # Avoid constructing insane-sized bytes objects for huge fills.
        chunk = color_bytes * 64
        full_chunks, remainder = divmod(pixels, 64)

        for _ in range(full_chunks):
            self._write_data(chunk)
        if remainder:
            self._write_data(color_bytes * remainder)

    def fill_screen(self, color: int) -> None:
        """Fill the entire display with a single color."""
        self.fill_rect(0, 0, self.width, self.height, color)

    def close(self) -> None:
        """Clean up SPI and GPIO."""
        try:
            self._spi.close()
        except Exception:
            pass
        GPIO.cleanup()


# -----------------------------
# Simple demo (color bars)
# -----------------------------

def _demo() -> None:
    disp = ST7735S()
    try:
        # Full-screen color bars
        colors: Tuple[int, ...] = (
            ST7735S.rgb565(255, 0, 0),    # red
            ST7735S.rgb565(0, 255, 0),    # green
            ST7735S.rgb565(0, 0, 255),    # blue
            ST7735S.rgb565(255, 255, 0),  # yellow
            ST7735S.rgb565(255, 0, 255),  # magenta
            ST7735S.rgb565(0, 255, 255),  # cyan
            ST7735S.rgb565(255, 255, 255) # white
        )

        bar_h = HEIGHT // len(colors)

        for i, c in enumerate(colors):
            disp.fill_rect(0, i * bar_h, WIDTH, bar_h, c)

        # Draw a small white cross in centre
        center_x = WIDTH // 2
        center_y = HEIGHT // 2
        white = ST7735S.rgb565(255, 255, 255)

        for dx in range(-10, 11):
            disp.draw_pixel(center_x + dx, center_y, white)
        for dy in range(-10, 11):
            disp.draw_pixel(center_x, center_y + dy, white)

        # Leave demo up
        while True:
            time.sleep(1)

    except KeyboardInterrupt:
        pass
    finally:
        disp.close()


if __name__ == "__main__":
    _demo()




```

end


[1.44 Inch LCD Screen Display Module For 2B / 3B / Zero / Zero W | eBay UK](https://www.ebay.co.uk/itm/397247114852?_skw=New+LCD+Display+Module+1.44+inch+128X128+For+Raspberry+pi+Zero+W&itmmeta=01KAJY874CZ6FJQ0F4D1KJF2YQ&hash=item5c7dc5ee64:g:jAsAAeSwHv1pEZZ3&itmprp=enc%3AAQAKAAABIFkggFvd1GGDu0w3yXCmi1dv%2BdsasJ1GcUfiJQR8kGntzFMpos5ARiYxkVn9SJlTslA%2FG9nIkr%2BENB7MvOp20r9ZNlrYB7sfP%2BGfP7E%2FjffMR7YY8RPJuLXTUFzUAhz33Ci01mB0MteydLTOMQrE2RhlO1PkHUaNrFqmocS9byZNVhQ9dZd2Ya78Eo5cubaqL7uaPzAMj3bCiU2urTlcO71mTUbC4zM2cm0fZLHXkzW835aJfwEVrjAD5Ytk61zBn5OljR3Sw1kePOzqCQOqan9ZEHrKsvtR6%2BI6EHVB7%2Fy9vpJRt3OLd89E83ZKpvl1W%2Fi%2BQJoJs7pmijDnXZ7BjtnHzdtWLz09xGNox1dByUr8ABNlrWX0mmWcSBfLAged3Q%3D%3D%7Ctkp%3ABk9SR7ryoN7UZg)

[0.96" ST7735S 80x160 SPI Colour IPS TFT LCD Display Module Arduino Raspberry Pi | eBay UK](https://www.ebay.co.uk/itm/313603433725?_skw=ST7735S+arduino&epid=22030179040&itmmeta=01KAJZTCXZ9831A3YDRPGC9MHY&hash=item490438a4fd:g:5G0AAOSwVyhfNzvu&itmprp=enc%3AAQAKAAAA0FkggFvd1GGDu0w3yXCmi1c1qvkwdv3UJVrY0wJTxdhAIao1PbPsvw1RAMzX8sxfOwSBOKa7bSxlJJnSUJ6w0XlQySNY9eLc0JPrvdtBma5W5zoHca315zxwdYG3rhMeCU0nIV8T%2Ba4cAjK7JNT9HCKFekR7%2FdbBtP%2FlHoKvAC71wiWnlCNiX5LTIBQOj0t2pozzCamiqYw97DaLmKf8xV6i3aP35H%2BaDiG5NxJiKWN3dboe6fVytQhhOLI0UcmLGdqkEkJPXZBXk%2Faxptds8vY%3D%7Ctkp%3ABk9SR5jP6d_UZg)

[Joystick Shield Expansion Board for Arduino UN - Thumbstick Buttons | eBay UK](https://www.ebay.co.uk/itm/296999205875?_skw=arduino+joystick+buttons&itmmeta=01KAK0M9K0WDB609KK5HTXYS6M&hash=item4526883bf3:g:P6cAAOSwnP5nqIgw&itmprp=enc%3AAQAKAAAA8FkggFvd1GGDu0w3yXCmi1f74QsaJHORlhSi720b%2Fbyryc2vxRLzte%2FNPRYu3iUj7jyUwby0TO5TXx8Flbx38DupUJ1V6wR0JwTbNMazItC9SXD6HRd%2B3lvwy76NEkIV%2BUVIgTEwwB5u3eT1xcGQkM0%2Fikb91dj3c4i1GusYQZeS5fbdjbL9lhaTfb28TSjwUT33YLTh%2F3%2FSPhUUs2NShiy0j8BK%2Bxtght46km50xM48HRzLkyixapSBnMPD0vhq9t8S2MXZ4dr34fIvKLqJQYgsbIlYq5hNQrCINBEk5BP8Uluxtvh6sjJXEfvHpRLECw%3D%3D%7Ctkp%3ABk9SR-KZ0eDUZg)

[1 Pin - 10 Pin Dupont Jump Wire Female to Female Jumper Breadboard Cable Lead | eBay UK](https://www.ebay.co.uk/itm/387336571249?_skw=ardujno+jump+lead&itmmeta=01KAK112H5965FRXT2YZXWYBVC&hash=item5a2f0f0971%3Ag%3AleYAAOSwzFBmzt4m&itmprp=enc%3AAQAKAAAA0FkggFvd1GGDu0w3yXCmi1dfjt2XFM%2Ba4qXveVDn%2BX4JS6X4t03Mq4y%2FBt3UqBILKAvVRcRpJwew1McPFY4TnV4ToUFfq9BJAjTS%2Bw8XHj3sTR%2BhfHNXu4pqZzkdSsng513AL32yH8H1hbtECzJqWt%2BN4PdF4rMQuxyQY6mwfCOR7N1WSRhU5Qo1%2BTpqmXwzXX96dsR%2FIhwRFEhZM4QSBwWuVj7uTXa%2BInnexcKFzDBndDDGmS4aya1ISh1c0kbldUf3kW3IouqU%2FkRML2OdZec%3D%7Ctkp%3ABk9SR8qphOHUZg&var=654595408467)


[RJ45 Ethernet Breakout Adaptor Female 8-Pin Screw Terminal CCTV (C4) : UK Seller | eBay UK](https://www.ebay.co.uk/itm/354308081344?_skw=RJ45+Breakout&itmmeta=01KAK1D610XZCP6MRMKS6665TC&hash=item527e6846c0%3Ag%3AadwAAOSw86JjN%7EhB&itmprp=enc%3AAQAKAAAA8FkggFvd1GGDu0w3yXCmi1eJIZZskY0iBtwSdHC2KO1JCS9P72WGbEPwpMMMoJgIWDTTL8IB%2FlCrNKO1f3bS8xnqo3eJNDvZAMNK3Hk2FR%2FdWY4A8SEtFwy8x5ZSfkp6nvNd7gc%2FQ0cRtBewpuvQVKGZ0oCnNGkySCq4obkFWeaRGb4ODbFMB0WhvK3ZYjmoaLi8UtAJN4owD9RkeQwYdxlza635y05Dl3ZCvBPF7hx9oPhwvyUiBoTqZyLzOCDIQcDie9NTmB7ozo8KoCiD%2FWXyZJeVMJDTUAYKuW21TvuFwpF4noZIOmIOpUEjIOv2Ag%3D%3D%7Ctkp%3ABk9SR9bgtOHUZg&LH_BIN=1)

[40pcs Dupont Male to Female 10cm Solderless Jumper Wire Breadboard Connectors : Amazon.co.uk: Business, Industry & Science](https://www.amazon.co.uk/Dupont-Female-Solderless-Breadboard-Connectors/dp/B0BLZCGP7T?crid=2QV3DGEXL8FEY&dib=eyJ2IjoiMSJ9.V2FzfAffMieiPOgx4KkuIdg7UAglOFPic4CP_Mo1Yrm3HiBO7NiiShz9si4yhJFbVCDCTNZcCrJJNDRVSPOjz3USZD2nUFkGkR_6UG3X2zgyHbG20cDy36BLnasWjDlbuqydn7PeH8fUzTl4HmsXL_X506Og5bafP28VhGGUfQECgtTXH7xPytV7S2l1O8uxVSpvYumPGtg-645A21Rda_JsgBxSf3o8KXQcsj5-OS6l_5tTB1HPeFZKFXiW6tHVRnJvDR_CcaAXASBy-dTuQu2QUYF5QfzakwJNzGWJeVM.RQ0VA2ZLaxn-Wne4LH5Pt972uuBEmap6EWEQcbncLhs&dib_tag=se&keywords=24awg+dupont&qid=1763723578&sprefix=24awg+dupont%2Caps%2C69&sr=8-1)

[SparkFun Qwiic Shield for Arduino Nano - SparkFun Electronics](https://www.sparkfun.com/sparkfun-qwiic-shield-for-arduino-nano.html)

[HyperPixel 4.0 Square - Hi-Res Display for Raspberry Pi](https://shop.pimoroni.com/products/hyperpixel-4-square?variant=30138251444307)

