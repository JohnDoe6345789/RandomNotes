
```python




#!/usr/bin/env python3
"""
MUD Maker: menu-driven silly MUD generator with optional local-AI hooks.

Usage:

    python mud_maker.py

You will be prompted for:
- AI backend preference (none, HuggingFace transformers, llama.cpp-style)
- Theme (fantasy, sci-fi, office, absurd)
- Silliness level
- Map size
- Extra quirks

Then this tool will generate a new MUD script (e.g. silly_mud.py).
"""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import List, Dict, Any


@dataclass
class Config:
    ai_backend: str
    theme: str
    silliness: str
    map_size: str
    quirks: List[str]
    output_path: Path


AI_BACKENDS = {
    "0": ("none", "No AI, just hardcoded silly text."),
    "1": ("hf_transformers", "Use HuggingFace transformers (if installed)."),
    "2": ("llama_cpp", "Use llama.cpp-style local model (if installed)."),
}

THEMES = {
    "1": "fantasy",
    "2": "sci_fi",
    "3": "office",
    "4": "absurd",
}

SILLINESS = {
    "1": "low",
    "2": "medium",
    "3": "high",
}

MAP_SIZES = {
    "1": "tiny",    # 3 rooms
    "2": "small",   # 5 rooms
    "3": "medium",  # 8 rooms
}

QUIRK_OPTIONS = {
    "1": ("talking_inventory", "Your inventory comments on your life choices."),
    "2": ("random_chaos_events", "Occasional surreal random events."),
    "3": ("npc_backchat", "NPCs roast the player when spoken to."),
    "4": ("death_is_weird", "Death sends you somewhere dumb instead of game over."),
}


def ask_menu_choice(
    title: str,
    options: Dict[str, Any],
    allow_empty: bool = False,
    default_key: str | None = None,
) -> str:
    print()
    print(f"== {title} ==")
    for key, value in options.items():
        if isinstance(value, tuple):
            label = value[0]
            desc = value[1]
            print(f"  {key}) {label:<18} - {desc}")
        else:
            print(f"  {key}) {value}")
    if allow_empty and default_key is not None:
        print(f"Press Enter for default [{default_key}]")

    while True:
        choice = input("> ").strip()
        if not choice and allow_empty and default_key is not None:
            choice = default_key
        if choice in options:
            return choice
        print("Invalid choice, please try again.")


def ask_multi_choice(
    title: str,
    options: Dict[str, tuple[str, str]],
) -> List[str]:
    print()
    print(f"== {title} ==")
    for key, (code, desc) in options.items():
        print(f"  {key}) {code:<18} - {desc}")
    print("Enter comma-separated numbers (e.g. 1,3) or blank for none.")

    while True:
        raw = input("> ").strip()
        if not raw:
            return []
        parts = [p.strip() for p in raw.split(",") if p.strip()]
        if all(p in options for p in parts):
            return [options[p][0] for p in parts]
        print("Invalid selection, please try again.")


def ask_output_filename(default_name: str = "silly_mud.py") -> Path:
    print()
    print(f"Output filename (default: {default_name}):")
    raw = input("> ").strip()
    if not raw:
        raw = default_name
    return Path(raw).expanduser().resolve()


def gather_config() -> Config:
    ai_choice = ask_menu_choice(
        "AI backend",
        AI_BACKENDS,
        allow_empty=True,
        default_key="0",
    )
    ai_backend = AI_BACKENDS[ai_choice][0]

    theme_choice = ask_menu_choice(
        "World theme",
        THEMES,
        allow_empty=True,
        default_key="4",
    )
    theme = THEMES[theme_choice]

    silly_choice = ask_menu_choice(
        "Silliness level",
        SILLINESS,
        allow_empty=True,
        default_key="2",
    )
    silliness = SILLINESS[silly_choice]

    map_choice = ask_menu_choice(
        "Map size",
        MAP_SIZES,
        allow_empty=True,
        default_key="2",
    )
    map_size = MAP_SIZES[map_choice]

    quirks = ask_multi_choice("Extra quirks", QUIRK_OPTIONS)
    out_path = ask_output_filename()

    return Config(
        ai_backend=ai_backend,
        theme=theme,
        silliness=silliness,
        map_size=map_size,
        quirks=quirks,
        output_path=out_path,
    )


def build_header(cfg: Config) -> str:
    lines = [
        '"""',
        f"Silly MUD, generated by mud_maker.py",
        "",
        "Configuration:",
        f"  AI backend : {cfg.ai_backend}",
        f"  Theme      : {cfg.theme}",
        f"  Silliness  : {cfg.silliness}",
        f"  Map size   : {cfg.map_size}",
        f"  Quirks     : {', '.join(cfg.quirks) if cfg.quirks else '(none)'}",
        '"""',
        "",
    ]
    return "\n".join(lines)


def build_imports(cfg: Config) -> str:
    base_imports = [
        "import sys",
        "import textwrap",
        "from dataclasses import dataclass",
        "from typing import Dict, List",
    ]
    ai_imports: List[str] = []
    if cfg.ai_backend == "hf_transformers":
        ai_imports.append("from typing import Optional")
        ai_imports.append("try:")
        ai_imports.append("    from transformers import pipeline as _hf_pipeline")
        ai_imports.append("except Exception:  # transformers is optional")
        ai_imports.append("    _hf_pipeline = None  # type: ignore[assignment]")
    elif cfg.ai_backend == "llama_cpp":
        ai_imports.append("from typing import Optional")
        ai_imports.append("try:")
        ai_imports.append("    from llama_cpp import Llama  # type: ignore[import]")
        ai_imports.append("except Exception:  # llama-cpp-python is optional")
        ai_imports.append("    Llama = None  # type: ignore[assignment]")

    return "\n".join(base_imports + ai_imports) + "\n\n"


def build_ai_brain(cfg: Config) -> str:
    if cfg.ai_backend == "none":
        return f"""\
class TextBrain:
    \"\"\"Dumb text brain that returns canned silly responses.\"\"\"

    def describe(self, prompt: str) -> str:
        base = "You feel like you have stepped into a cheap text adventure."
        return base + " [" + {repr(cfg.theme)!r} + " / " + {repr(cfg.silliness)!r} + "]"

    def npc_reply(self, player_line: str) -> str:
        return "The NPC stares at you and says: 'Did you really just say: " + "{'{}'}".format(player_line) + " ?'"
"""
    if cfg.ai_backend == "hf_transformers":
        return """\
class TextBrain:
    \"\"\"HuggingFace-backed text brain (if transformers is installed).\"\"\"

    def __init__(self) -> None:
        self._pipe = None
        if '_hf_pipeline' in globals() and _hf_pipeline is not None:
            try:
                self._pipe = _hf_pipeline(
                    'text-generation',
                    model='gpt2',
                    device='cpu',
                )
            except Exception:
                self._pipe = None

    def _fallback(self, prompt: str) -> str:
        return "Your mind goes blank. The narration fizzles out: " + prompt[:80]

    def _gen(self, prompt: str, max_new_tokens: int = 40) -> str:
        if self._pipe is None:
            return self._fallback(prompt)
        try:
            out = self._pipe(
                prompt,
                max_new_tokens=max_new_tokens,
                num_return_sequences=1,
                do_sample=True,
                temperature=0.9,
            )[0]["generated_text"]
            return out[len(prompt):].strip() or self._fallback(prompt)
        except Exception as exc:
            return self._fallback(f"{prompt} [error: {exc}]")

    def describe(self, prompt: str) -> str:
        return self._gen("Describe a silly game world. " + prompt)

    def npc_reply(self, player_line: str) -> str:
        return self._gen("In one sentence, reply with a snarky comment to: " + player_line)
"""
    if cfg.ai_backend == "llama_cpp":
        return """\
class TextBrain:
    \"\"\"llama.cpp-backed text brain (if llama_cpp is installed).\"\"\"

    def __init__(self) -> None:
        self._llm = None
        if 'Llama' in globals() and Llama is not None:
            try:
                # Adjust model path to your local model file.
                self._llm = Llama(model_path="local-model.gguf")
            except Exception:
                self._llm = None

    def _fallback(self, prompt: str) -> str:
        return "Your brain echoes: " + prompt[:80]

    def _gen(self, prompt: str, max_tokens: int = 40) -> str:
        if self._llm is None:
            return self._fallback(prompt)
        try:
            out = self._llm(
                prompt,
                max_tokens=max_tokens,
                temperature=0.8,
                stop=["\n"],
            )
            text = out["choices"][0]["text"]
            return text.strip() or self._fallback(prompt)
        except Exception as exc:
            return self._fallback(f"{prompt} [error: {exc}]")

    def describe(self, prompt: str) -> str:
        return self._gen("Describe a strange, humorous text adventure. " + prompt)

    def npc_reply(self, player_line: str) -> str:
        return self._gen("Reply to the player with sarcasm: " + player_line)
"""
    # Fallback (should not hit)
    return "class TextBrain:\n    def describe(self, prompt: str) -> str:\n        return prompt\n"


def build_world(cfg: Config) -> str:
    # Very small, themed templates
    if cfg.theme == "fantasy":
        rooms = {
            "square": "You stand in a cobblestone town square where a chicken seems to be the mayor.",
            "tavern": "A suspiciously quiet tavern. The chairs are clearly plotting something.",
            "forest": "Twisty trees whisper spoilers about your destiny.",
            "tower": "A wizard's tower full of unattended experiments.",
            "dungeon": "The dungeon smells like budget cuts.",
        }
    elif cfg.theme == "sci_fi":
        rooms = {
            "airlock": "You are by an airlock that has too many warning labels to read.",
            "bridge": "The ship's bridge, staffed entirely by interns.",
            "lab": "A science lab where half the equipment is marked 'experimental-ish'.",
            "cargo": "Cargo bay full of boxes labelled 'mysterious stuff'.",
            "engine": "Engine room humming to itself in binary.",
        }
    elif cfg.theme == "office":
        rooms = {
            "reception": "Reception desk with a sign: 'Welcome, please lower your expectations'.",
            "open_space": "An open-plan office where productivity goes to nap.",
            "meeting": "A meeting room booked solid until the heat death of the universe.",
            "kitchen": "Office kitchen with an immortal sandwich in the fridge.",
            "server": "Server room. The servers judge you silently.",
        }
    else:  # absurd
        rooms = {
            "void": "You float in a featureless void. A sign reads: 'Under construction'.",
            "laundry": "Infinite cosmic laundrette. Socks vanish at superposition.",
            "cheese": "A moon made of cheese that denies being made of cheese.",
            "library": "Library of unwritten books. The silence is copyrighted.",
            "bus": "Interdimensional bus stop with no timetable, just vibes.",
        }

    if cfg.map_size == "tiny":
        keys = list(rooms.keys())[:3]
    elif cfg.map_size == "small":
        keys = list(rooms.keys())[:5]
    else:
        keys = list(rooms.keys())

    # Simple linear+side connections
    ordered = keys
    connections: Dict[str, Dict[str, str]] = {}
    for i, name in enumerate(ordered):
        exits: Dict[str, str] = {}
        if i > 0:
            exits["west"] = ordered[i - 1]
        if i < len(ordered) - 1:
            exits["east"] = ordered[i + 1]
        connections[name] = exits

    world_def = [
        "@dataclass",
        "class Room:",
        "    name: str",
        "    description: str",
        "    exits: Dict[str, str]",
        "",
        "",
        "WORLD: Dict[str, Room] = {}",
        "",
        "def _init_world() -> None:",
    ]

    for key in ordered:
        desc = rooms[key].replace('"', '\\"')
        exits = connections[key]
        exits_repr = ", ".join(f'"{d}": "{dest}"' for d, dest in exits.items())
        world_def.append(
            f'    WORLD["{key}"] = Room('
            f'name="{key}", description="{desc}", exits={{ {exits_repr} }})'
        )

    world_def.append("")
    world_def.append('START_ROOM = "{}"'.format(ordered[0]))
    world_def.append("")

    return "\n".join(world_def) + "\n\n"


def build_quirk_helpers(cfg: Config) -> str:
    parts: List[str] = []

    if "talking_inventory" in cfg.quirks:
        parts.append(
            """\
def inventory_comment(inv: List[str]) -> str:
    if not inv:
        return "Your inventory is tragically empty. Minimalism, or poor planning?"
    return "You carry: " + ", ".join(inv) + ". They judge you silently."
"""
        )

    if "random_chaos_events" in cfg.quirks:
        parts.append(
            """\
import random

def maybe_chaos() -> str:
    if random.random() < 0.2:
        return random.choice([
            "A duck in a top hat walks through and leaves without explanation.",
            "Gravity gets bored and takes a second off.",
            "You hear the narrator arguing with the game designer.",
            "A pop-up appears: 'You have unsaved progress in reality.'",
        ])
    return ""
"""
        )

    if "npc_backchat" in cfg.quirks:
        parts.append(
            """\
def npc_backchat(line: str) -> str:
    insults = [
        "That was... a choice of words.",
        "Bold of you to say that out loud.",
        "I have heard worse. Mostly from you.",
        "Did you rehearse that line? You shouldn't have.",
    ]
    return insults[hash(line) % len(insults)]
"""
        )

    if "death_is_weird" in cfg.quirks:
        parts.append(
            """\
def weird_death_transport() -> str:
    return "Instead of dying, you wake up in a slightly more awkward version of reality."
"""
        )

    return "\n\n".join(parts) + ("\n\n" if parts else "")


def build_main_loop(cfg: Config) -> str:
    lines = [
        "def describe_room(brain: TextBrain, room: Room) -> None:",
        "    base = room.description",
        "    extra = brain.describe(base)",
        "    print()",
        "    print(textwrap.fill(base, width=78))",
        "    if extra and extra != base:",
        "        print()",
        "        print(textwrap.fill(extra, width=78))",
        "",
        "",
        "def game_loop() -> None:",
        "    _init_world()",
        "    brain = TextBrain()",
        "    current = START_ROOM",
        "    inventory: List[str] = []",
        "    print('Welcome to your silly generated MUD! Type help for commands.')",
        "    while True:",
        "        room = WORLD[current]",
        "        describe_room(brain, room)",
    ]

    if "random_chaos_events" in cfg.quirks:
        lines.append("        chaos = maybe_chaos()")
        lines.append("        if chaos:")
        lines.append("            print()")
        lines.append("            print(textwrap.fill(chaos, width=78))")

    lines += [
        "        print()",
        "        print('Exits:', ', '.join(room.exits.keys()) or 'none')",
        "        cmd = input('> ').strip()",
        "        if not cmd:",
        "            continue",
        "        parts = cmd.split(maxsplit=1)",
        "        verb = parts[0].lower()",
        "        arg = parts[1] if len(parts) > 1 else ''",
        "",
        "        if verb in ('quit', 'exit'):",
        "            print('You fade out of this ridiculous world.')",
        "            break",
        "        if verb == 'help':",
        "            print('Commands: look, go <dir>, say <text>, take <thing>, inv, quit')",
        "            continue",
        "        if verb == 'look':",
        "            # loop back to show room again",
        "            continue",
        "        if verb == 'go':",
        "            if not arg:",
        "                print('Go where?')",
        "                continue",
        "            dest = room.exits.get(arg.lower())",
        "            if not dest:",
        "                print('You bump into the edges of game design.')",
        "                continue",
        "            current = dest",
        "            continue",
        "        if verb == 'take':",
        "            if not arg:",
        "                print('Take what exactly, the ambience?')",
        "                continue",
        "            inventory.append(arg)",
        "            print(f'You take the {arg}. It is now your problem.')",
        "            continue",
        "        if verb in ('inv', 'inventory'):",
    ]

    if "talking_inventory" in cfg.quirks:
        lines.append("            print(inventory_comment(inventory))")
    else:
        lines.append("            print('Inventory:', inventory or 'nothing at all')")

    lines += [
        "            continue",
        "        if verb == 'say':",
        "            if not arg:",
        "                print('You say nothing. It is your most profound statement yet.')",
        "                continue",
        "            base_reply = brain.npc_reply(arg)",
    ]

    if "npc_backchat" in cfg.quirks:
        lines.append("            spice = npc_backchat(arg)")
        lines.append("            print(textwrap.fill(base_reply, width=78))")
        lines.append("            print(textwrap.fill(spice, width=78))")
    else:
        lines.append("            print(textwrap.fill(base_reply, width=78))")

    lines += [
        "            continue",
        "",
        "        print(\"The world does not understand that command (yet).\")",
        "",
        "",
        "def main() -> None:",
        "    try:",
        "        game_loop()",
        "    except KeyboardInterrupt:",
        "        print('\\nYou drop the connection to this universe.')",
        "",
        "",
        "if __name__ == '__main__':",
        "    main()",
        "",
    ]

    return "\n".join(lines)


def generate_mud_script(cfg: Config) -> str:
    pieces = [
        build_header(cfg),
        build_imports(cfg),
        build_ai_brain(cfg),
        "",
        build_world(cfg),
        build_quirk_helpers(cfg),
        build_main_loop(cfg),
    ]
    return "\n".join(pieces)


def write_script(cfg: Config, text: str) -> None:
    cfg.output_path.write_text(text, encoding="utf-8")
    print()
    print(f"Generated MUD script at: {cfg.output_path}")
    print("Run it with: python", cfg.output_path.name)


def main() -> None:
    cfg = gather_config()
    script_text = generate_mud_script(cfg)
    write_script(cfg, script_text)


if __name__ == "__main__":
    main()






```


```python



```






![[humorous_mud.zip]]










